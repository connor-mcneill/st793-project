---
title: "Simulation"
format: html
editor: visual
---

# Load Packages

```{r, message=F, info=F}
require(glmnet)
require(parallel)
```

# Generate Data

```{r}
# Generate negative binomial data.
# PARAMS:
# n: Number of observations we want
# m: Number of coefficients. p=Bm, and this model only runs when p>n.
# B: Number of "blocks" that will form the block-diagonal Sigma matrix
# RETURN:
# List of 3 items: Sigma, D, and O

setting<-function(n, m, B, beta){
  p<-B*m
  
  # Calculate Sigma matrix
  s<-floor(n^0.8)
  w<-(1:p-s)^{-4}
  W<-sum(w[(s+1):length(w)])
  diag.vec<-rep(1, p) # Start as a vector, easier to use logic with
  diag.vec[(s+1):p]<-((n-s)*w/W)[(s+1):p]
  D<-diag(diag.vec, nrow=p)
  if(B==1) { 
      save=rnorm(p^2,0,1)
      orignal=matrix(save,p,p)
  } else {
      p_sub=p/B
      orignal=matrix(0,p,p)
      for(i in 1:B){
        orignal[((i-1)*p_sub+1):(i*p_sub), ((i-1)*p_sub+1):(i*p_sub)]=matrix(rnorm(p_sub^2,0,1),p_sub,p_sub)
      }
  }
  symtric=orignal+t(orignal)           
  O=as.matrix(eigen(symtric)$vectors)
  
  Gamma<-O%*%D%*%t(O)
  return(list(Sigma=Gamma%*%t(Gamma), D=D, O=O))
}
```

```{r}
ret.lst<-setting(10, 11, B=3, beta=2)
ret.lst$Sigma
```

## Running Code

```{r}
View(ret.lst$O)
```
