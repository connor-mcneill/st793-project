---
title: "Simulation"
format: html
editor: visual
---

# Load Packages

```{r, message=F, info=F}
require(glmnet)
require(parallel)
```

# Generate Data

```{r}
# Generate negative binomial data.
# PARAMS:
# n: Number of observations we want
# m: Number of coefficients. p=Bm, and this model only runs when p>n.
# B: Number of "blocks" that will form the block-diagonal Sigma matrix
# RETURN:
# List of 3 items: Sigma, D, and O

setting<-function(n, m, B, beta){
  
  p<-B*m
  # Compute D: diagonal matrix in the decomposition of Sigma
  s<-floor(n^0.8)
  ## define weights as described in paper
  w = numeric(p)
  w[(s+1):p] = (1:(p-s))^-4
  W<-sum(w)
  ## Start as a vector, easier to use logic with
  ## then compute D from the weights and s
  ## finally take the sqrt as we are working with
  ## Gamma = O D^{1/2} O^T 
  diag.vec<-rep(1, p) 
  diag.vec[(s+1):p]<-((n-s)*w/W)[(s+1):p]
  D.sqrt <-diag(sqrt(diag.vec), nrow=p)
  
  # Compute O matrix
  ## If B = 1, then we do not have a blockwise matrix
  ## so generate p x p matrix from standard normal
  ## then make it orthogonal
  if(B==1) { 
      temp = matrix(rnorm(p^2,0,1),p,p)
      temp.sym = temp + t(temp)
      O = as.matrix(eigen(temp.sym, TRUE)$vectors)
  ## otherwise, generate a block-wise diagonal matrix
  ## with each block being mxm from standard normal
  ## and orthogonal
  } else {
      O = matrix(0,p,p)
      for(i in 1:B){
        temp = matrix(rnorm(m^2,0,1),m,m)
        temp.sym = temp + t(temp)
        O.temp = as.matrix(eigen(temp.sym, TRUE)$vectors)
        O[((i-1)*m+1):(i*m), ((i-1)*m+1):(i*m)] = O.temp
      }
  }
  
  # Generate Gamma which is Gamma = O D^{1/2} O^T = Sigma^{1/2}
  Gamma<-O%*%D.sqrt%*%t(O)
  return(list(Sigma=Gamma%*%t(Gamma), D=D, O=O))
}
```

```{r}
ret.lst<-setting(10, 11, B=3, beta=2)
ret.lst$Sigma
```

## Running Code

```{r}
View(ret.lst$O)
```
